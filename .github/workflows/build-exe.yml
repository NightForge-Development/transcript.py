name: Build Whisper Transcription Tool

on:
  push:
    tags: ['v*']  # Trigger on version tags
  workflow_dispatch:  # Manual trigger

env:
  # ===== CORE CONFIGURATION =====
  APP_NAME: "SoundTranscriber"
  PYTHON_VERSION: "3.11.9"
  BUILD_ROOT: "exe_build"  # Root directory for build resources
  # MAIN_SCRIPT will be defined in jobs context
  
  # ===== BUILD CONFIGURATION =====
  # OUTPUT_EXE will be defined in jobs context
  # ICON_FILE will be defined in jobs context
  # ADDITIONAL_FILES will be defined in jobs context
  CONSOLE_APP: "false"  # Set to "true" for console apps
  
  # ===== DEPENDENCY CONFIGURATION =====
  USE_CHOCO_FFMPEG: "true"
  WHISPER_MODEL: "small"  # tiny, base, small, medium, large

jobs:
  build-windows-exe:
    name: Build Windows EXE
    runs-on: windows-latest
    
    env:
      # Define these here where we can reference the global env vars
      MAIN_SCRIPT: "${{ env.BUILD_ROOT }}/main.py"
      OUTPUT_EXE: "${{ env.APP_NAME }}.exe"
      ICON_FILE: "${{ env.BUILD_ROOT }}/app.ico"
      ADDITIONAL_FILES: "${{ env.BUILD_ROOT }}/README.md ${{ env.BUILD_ROOT }}/LICENSE"

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Verify build directory structure
      run: |
        if (-not (Test-Path "${{ env.BUILD_ROOT }}")) {
          Write-Error "Build root directory '${{ env.BUILD_ROOT }}' not found!"
          exit 1
        }
        if (-not (Test-Path "${{ env.MAIN_SCRIPT }}")) {
          Write-Error "Main script '${{ env.MAIN_SCRIPT }}' not found!"
          exit 1
        }

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Chocolatey (if needed)
      if: env.USE_CHOCO_FFMPEG == 'true'
      run: |
        Set-ExecutionPolicy Bypass -Scope Process -Force
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
        iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

    - name: Install FFmpeg via Chocolatey
      if: env.USE_CHOCO_FFMPEG == 'true'
      run: choco install ffmpeg -y --no-progress

    - name: Install Python dependencies
      working-directory: ${{ env.BUILD_ROOT }}
      run: |
        python -m pip install --upgrade pip
        pip install pyinstaller
        pip install git+https://github.com/openai/whisper.git
        if (Test-Path "requirements.txt") {
          pip install -r requirements.txt
        }

    - name: Generate PyInstaller command
      id: pyinstaller
      run: |
        $command = "pyinstaller --noconfirm --clean --onefile"
        $command += " --name ${{ env.APP_NAME }}"
        $command += " --distpath ../dist"
        $command += " --workpath ../build"
        $command += " --specpath ../build"
        
        if ("${{ env.ICON_FILE }}" -ne "" -and (Test-Path "${{ env.ICON_FILE }}")) {
          $command += " --icon ${{ env.ICON_FILE }}"
        }
        
        if ("${{ env.CONSOLE_APP }}" -eq "false") {
          $command += " --windowed"
        }
        
        $command += " ${{ env.MAIN_SCRIPT }}"
        
        echo "command=$command" >> $env:GITHUB_OUTPUT

    - name: Run PyInstaller
      working-directory: ${{ env.BUILD_ROOT }}
      run: ${{ steps.pyinstaller.outputs.command }}

    - name: Package additional files
      if: env.ADDITIONAL_FILES != ''
      run: |
        $destDir = "../dist/${{ env.APP_NAME }}_files"
        New-Item -ItemType Directory -Path $destDir -Force
        
        $files = "${{ env.ADDITIONAL_FILES }}".Split(" ")
        foreach ($file in $files) {
          if (Test-Path $file) {
            Copy-Item $file $destDir
          }
        }

    - name: Create release package
      run: |
        $version = git describe --tags --abbrev=0
        $zipName = "${{ env.APP_NAME }}_${version}.zip"
        $sourceFiles = @(
          "dist/${{ env.APP_NAME }}.exe",
          "dist/${{ env.APP_NAME }}_files/*"
        )
        Compress-Archive -Path $sourceFiles -DestinationPath "dist/$zipName" -Force

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}_Build
        path: dist/${{ env.APP_NAME }}_*.zip

    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: dist/${{ env.APP_NAME }}_*.zip
        generate_release_notes: true
